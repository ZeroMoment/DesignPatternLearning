## DesignPattern
![建模样例图](https://raw.codehub.cn/p/promote/d/DesignPatternLearning/git/raw/master/images/uml_demo.png?token=X5b1G6KsDdV0VBszcfedzHt22FGfCPvBYqXpIPnGaK&download=true)

### 1.简单工厂模式
`根据不同类型，创建不同的对象（基于一个基类）`

### 2.工厂方法
```
定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
——为什么弃用简单工厂方法，而选择工厂方法这类增加接口跟类的方式？因为如果使用简单工厂模式，下次有新的运算需求，
我们需要到工厂类增加新的case，修改原有的类。这不但对扩展开放了，对修改也开放了，这样就违背了开放-封闭原则。
（工厂方法是简单工厂模式的进一步抽象，也有缺点：每次有新业务，需要修改客户端（调用处的）代码，后面抽象工厂处会有反射升级方案）
```

### 3.抽象工厂模式
```
提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
——一系列任务需要多种类似工厂实现类完成各自具体任务时，可以将工厂再往上抽象一层。抽象后，具体实例化，可以使用反射。
将if/else分支判断创建不同对象，改为根据类全名的变量去使用反射进行实例化
```
#### 工厂总结
```
简单工厂：不能算是真正意义上的设计模式，但可以将客户程序从具体类解耦。

工厂方法：使用继承，把对象的创建委托给子类，由子类来实现创建方法，可以看作是抽象工厂模式中只有单一产品的情况。

抽象工厂：使对象的创建被实现在工厂接口所暴露出来的方法中。

工厂模式可以帮助我们针对抽象/接口编程，而不是针对具体类编程，在不同的场景下按具体情况来使用。
```

### 4.策略模式
```
同类算法（也可以是任意类型），细节处理不一的变化部分，抽象封装起来，使用一个关联类（包装类），基于抽象生成不同对象，调用相关实现方法。
以达到调用方对具体实现过程的隔离。
```

### 5.单一职责原则
```
就一个类而言，应该仅有一个引起它变化的原因
——一个业务，尽可能的找出哪些是界面，哪些是逻辑，然后进行分离。
分离的逻辑类，也使每个类的功能尽量单一
```

### 6.开放-封闭原则
```
软件实体（类，模块，函数等等）应该可以扩展，但是不可修改
——对于扩展是开放的，对于更改是封闭的。在最初编码时，假设变化不会发生，
当变化发生时，我们就要创建抽象来隔离以后发生的同类变化（例：简单计算器的实现-简单工厂模式）
```

### 7.依赖倒置原则
```
针对接口编程，不要针对实现编程
——这个原则的保证，引申出另一个原则：里氏代换原则（子类型必须能够替换掉它们的父类型）
依赖倒转其实就是谁也不依靠谁，除了约定的接口，大家都可以灵活自如
```

### 8.装饰模式
```
动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
——说白了，就是定义一个抽象接口，再定定义一个抽象的装饰类接口实现上层的抽象接口。
后续的所有装饰实现类，可以随意扩展接口的实现。
```

### 9.代理模式
```
为其他对象提供一种代理，以控制对这个对象的访问
——定义一个代理类跟真实调用对象类的公用接口，这样就在任何使用真实调用对象的地方，都可以使用proxy

代理模式的好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。

这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需要修改，可以通过代理的方式来扩展该方法。
（应用：不想修改原来的，或者不想直接访问特定对象，增加自定义日志等）
```
#### 静态代理
```
静态代理需要先定义接口，被代理对象与代理对象一起实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。
优点：静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。
缺点：静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。
```
![静态代理a](https://struggling119.coding.net/p/promote/d/DesignPatternLearning/git/tree/master/images/proxy_s_1.png)
![静态代理b](https://raw.codehub.cn/p/promote/d/DesignPatternLearning/git/raw/master/images/proxy_s_2.png?token=gSmvKs8D48XZrFvHRl0c9aGGXaoUbcg6gf46ZSQ5lm&download=true)
#### 动态代理
![动态代理a](/images/proxy_d_1.png)
```
a.JDK动态代理对象不需要实现接口，只有目标对象需要实现接口。
b.实现基于接口的动态代理需要利用JDK中的API，在JVM内存中动态的构建Proxy对象。
c.需要使用到 java.lang.reflect.Proxy，和其newProxyInstance方法，但是该方法需要接收三个参数。
    @RecentlyNonNull
    public static Object newProxyInstance(@RecentlyNullable ClassLoader loader, @RecentlyNonNull Class<?>[] interfaces, @RecentlyNonNull InvocationHandler h) {
        //SOURCE TODO
    }
注意该方法是在Proxy类中是静态方法，且接收的三个参数依次为：

a.ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的。
b.Class<?>[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型。
c.InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。
```



### 10.原型模式（Prototype）
```
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象（clone）
```

### 11.模板方法模式
```
定义一个操作中的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
——（应用：最常见的，Android项目搭建基类，让子类return布局id以实现加载不同的布局）
```

### 12.迪米特法则（最少知识原则）
```
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要另一个类的某一个方法的话，可以通过第三者转发这个调用
——在类的结构设计上，每一个类都应当尽量降低成员的访问权限
```

### 13.外观模式
```
为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
——（应用：当接手老项目，一个module里代码调用很混乱，你新的业务又有很多需要一样的互相交叉调用的地方。此时
你可以设计一个新的类作为中间件，处理跟老module里混乱调用的逻辑并提供新的简单易用接口给外部使用）
```

### 14.建造者模式（Builder）
```
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
——主要用于创建一些复杂对象，这些对象内部构建间的建造顺序通常是稳定的，但是对象内部的构建通常面临着复杂变化（如：应用内的同风格的多种弹框）
```

### 15.观察者模式
```
定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主体对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己
```


### 16.状态模式
```
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
——状态模式主要解决的睡觉哦当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，
可以把复杂的判断逻辑简化
```

### 17.适配器模式
```
将一个类的接口转换成客户端希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
——系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。
适配器模式主要用于希望复用一些现存类，但是接口又与复用环境要求不一致的情况。
（其实就是弄一个新的接口，在接口实现里，调用的是老代码里的实现）
```

### 18.备忘录模式
```
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态
（备份部分数据，备份细节在备份类中实现）
```

### 19.组合模式
```
将对象组合成树形结构以表示’部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
——组合模式让客户可以一致地使用组合结构和单个对象
```

### 20.迭代器模式
```
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示
——实用价值已不大，各语言都有for循环这类的遍历支持了，也提供获取对应迭代器的方法。
（当然，如果业务中频繁需要访问某个聚合对象的第一个、最后一个或当前对象以及是否到结尾，此时迭代器模式还是适用的——要求多种迭代方式时）
另外：在实现定义迭代器时，最好进行抽象。因为后续如果要支持多种迭代方式，替换具体迭代实现即可。
```

### 21.单例模式
`保证一个类仅有一个实例，并提供一个访问它的全局方法`

### 22.桥接模式(实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少耦合)
```
定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化
——什么叫抽象与它的实现分离？这并不是说，让抽象类与其派生类分离，因为这没有任何意义。
实现指的是抽象类与它的派生类用来实现自己的对象。
（包bridge:demo而言：就是让‘手机’既可以按品牌分类，也可以按照功能分类）

使用的设计原则：
合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承
——聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。
（比分说，大雁有两个翅膀，翅膀跟大雁就是部分和整体的关系，并且他们的生命周期相同，于是大雁和翅膀就是合成关系；
而大雁是群居动物，所以每一只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群就是聚合关系。）

合成/聚合复用原则的好处：优先使用对象的合成/聚合将有助你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次
会保持较小规模，并且不太可能增长为不可控制的庞然大物（多层继承）
```
![聚合前设计](https://struggling119.coding.net/p/promote/d/DesignPatternLearning/git/tree/master/images/bridge_a.png)
![聚合后设计](https://struggling119.coding.net/p/promote/d/DesignPatternLearning/git/tree/master/images/bridge_b.png)

### 23.命令模式
```
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
```

### 24.职责链模式
```
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到
有一个对象处理它为止
```

### 25.中介者模式（说白了，就是在复杂调用引用的场景下，弄一个中间对象去统一管理调用）
```
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们直接的交互。
——一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合。
```

### 26.享元模式
```
运用共享技术有效地支持大量细粒度的对象
——享元模式可以避免大量非常相似类的开销。在需要大量细粒度的类实例来实现业务时，如果发现这些实例除了几个参数（数据）不同外，
其他结构基本相同，这时就可以考虑使用享元模式
```
![](https://struggling119.coding.net/p/promote/d/DesignPatternLearning/git/tree/master/images/flyweight.png)


## 后两种模式，可以简单理解为多用封装，实现开放-封闭原则就行，不用过多理解。

### 27.解释器模式（略）
```
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
——如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个
解释器，该解释器通过解释这些句子来解决该问题。（应用：正则表达式、早期手机按数字谱曲的应用）
```

### 28.访问者模式（略）
```
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作
——比如：男人女人对成功、失败、恋爱...等待不同状态的人生态度。可以定义一个状态类接口，定义男女分别不同反应的接口；然后再
抽象所有状态的一个接口action，各个状态的实现类完成最终的男人、女人对不同状态的实现（双分派：具体状态作为参数传递给男人类，
男人类对具体状态做出反应时，将自己this传递到具体状态实现里，二次分派）

实现的简单描述：状态接口action里有男女两个反应的方法定义，方法分别接受男人、女人对象为参数。而男人、女人的超类Person类定义
接收具体状态的方法，接收参数就是action

只适合结构稳定不变的情况：如上，人按性别分只能分男、女【很少用】
```

![](https://struggling119.coding.net/p/promote/d/DesignPatternLearning/git/tree/master/images/design_all.png)